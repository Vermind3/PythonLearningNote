深拷贝与浅拷贝
a = [1,2,3,4,5]
如果直接用b = a
则之后对b的任何修改都会影响到a，反之亦然，这是因为 = 是浅拷贝，python实际上只是将a的引用地址给了b，所以会出现这种情况
如果使用id(a),和id(b)验证会发现他们的地址都是一样的
所以如果希望a和b两个互不干扰，需要使用.copy()
也就是
b = a.copy()